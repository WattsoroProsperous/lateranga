"use server";

import { createClient } from "@/lib/supabase/server";
import { createAdminClient } from "@/lib/supabase/admin";
import { createOrderSchema, updateOrderStatusSchema } from "@/lib/validations/order.schema";
import { revalidatePath } from "next/cache";
import type { Order } from "@/types";

export async function createOrder(input: unknown) {
  const parsed = createOrderSchema.safeParse(input);
  if (!parsed.success) {
    return { error: parsed.error.issues[0]?.message ?? "Données invalides" };
  }

  const supabase = createAdminClient();
  const data = parsed.data;

  // Calculate totals server-side
  const subtotal = data.items.reduce(
    (sum, item) => sum + item.price * item.qty,
    0
  );
  const deliveryFee = data.order_type === "livraison" ? 1000 : 0;
  const total = subtotal + deliveryFee;

  // Get current user if authenticated
  const authSupabase = await createClient();
  const {
    data: { user },
  } = await authSupabase.auth.getUser();

  // Insert order (order_number generated by trigger)
  const { data: orderData, error: orderError } = await supabase
    .from("orders")
    .insert({
      order_number: "",
      customer_id: user?.id ?? null,
      status: "pending" as const,
      order_type: data.order_type,
      client_name: data.client_name,
      client_phone: data.client_phone,
      delivery_address: data.delivery_address ?? null,
      notes: data.notes ?? null,
      subtotal,
      delivery_fee: deliveryFee,
      total,
    } as never)
    .select()
    .single();

  const order = orderData as Order | null;

  if (orderError || !order) {
    return { error: orderError?.message ?? "Erreur lors de la création de la commande" };
  }

  // Insert order items
  const orderItems = data.items.map((item) => ({
    order_id: order.id,
    menu_item_id: null as string | null,
    item_name: item.name,
    item_price: item.price,
    quantity: item.qty,
    line_total: item.price * item.qty,
    size_variant: item.sizeVariant ?? null,
  }));

  const { error: itemsError } = await supabase
    .from("order_items")
    .insert(orderItems as never);

  if (itemsError) {
    // Attempt cleanup
    await supabase.from("orders").delete().eq("id", order.id);
    return { error: "Erreur lors de l'ajout des articles" };
  }

  // Send WhatsApp notification (non-blocking)
  sendWhatsAppNotification(order, data.items).catch(console.error);

  revalidatePath("/admin/orders");
  return { success: true, orderNumber: order.order_number };
}

async function sendWhatsAppNotification(
  order: { id: string; client_name: string; client_phone: string; total: number },
  items: Array<{ name: string; qty: number }>
) {
  const phoneNumberId = process.env.WHATSAPP_PHONE_NUMBER_ID;
  const accessToken = process.env.WHATSAPP_ACCESS_TOKEN;
  const recipientPhone = process.env.WHATSAPP_RECIPIENT_PHONE;

  if (!phoneNumberId || !accessToken || !recipientPhone) return;

  const itemsSummary = items.map((i) => `${i.qty}x ${i.name}`).join(", ");

  try {
    await fetch(
      `https://graph.facebook.com/v18.0/${phoneNumberId}/messages`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          messaging_product: "whatsapp",
          to: recipientPhone,
          type: "template",
          template: {
            name: "order_confirmation",
            language: { code: "fr" },
            components: [
              {
                type: "body",
                parameters: [
                  { type: "text", text: order.client_name },
                  { type: "text", text: order.client_phone },
                  { type: "text", text: itemsSummary },
                  { type: "text", text: `${order.total.toLocaleString("fr-CI")} FCFA` },
                ],
              },
            ],
          },
        }),
      }
    );
  } catch (err) {
    console.error("WhatsApp notification failed:", err);
  }
}

export async function updateOrderStatus(input: unknown) {
  const parsed = updateOrderStatusSchema.safeParse(input);
  if (!parsed.success) {
    return { error: parsed.error.issues[0]?.message ?? "Données invalides" };
  }

  const supabase = await createClient();
  const updateData: Record<string, unknown> = { status: parsed.data.status };

  if (parsed.data.status === "cancelled" && parsed.data.cancellation_reason) {
    updateData.cancellation_reason = parsed.data.cancellation_reason;
  }

  const { error } = await supabase
    .from("orders")
    .update(updateData as never)
    .eq("id", parsed.data.id);

  if (error) return { error: error.message };

  revalidatePath("/admin/orders");
  return { success: true };
}

export async function getOrderAnalytics() {
  const supabase = await createClient();

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const [todayRes, weekRes, monthRes] = await Promise.all([
    supabase
      .from("orders")
      .select("total")
      .gte("created_at", today.toISOString())
      .neq("status", "cancelled"),
    supabase
      .from("orders")
      .select("total")
      .gte("created_at", new Date(Date.now() - 7 * 86400000).toISOString())
      .neq("status", "cancelled"),
    supabase
      .from("orders")
      .select("total")
      .gte("created_at", new Date(Date.now() - 30 * 86400000).toISOString())
      .neq("status", "cancelled"),
  ]);

  type TotalRow = { total: number | null };
  const todayData = (todayRes.data ?? []) as TotalRow[];
  const weekData = (weekRes.data ?? []) as TotalRow[];
  const monthData = (monthRes.data ?? []) as TotalRow[];

  return {
    today: {
      count: todayData.length,
      revenue: todayData.reduce((s, o) => s + (o.total ?? 0), 0),
    },
    week: {
      count: weekData.length,
      revenue: weekData.reduce((s, o) => s + (o.total ?? 0), 0),
    },
    month: {
      count: monthData.length,
      revenue: monthData.reduce((s, o) => s + (o.total ?? 0), 0),
    },
  };
}
